'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var solidJs = require('solid-js');
var regexparam = require('regexparam');
var web = require('solid-js/web');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var regexparam__default = /*#__PURE__*/_interopDefaultLegacy(regexparam);

const $RAW = Symbol("store-raw"),
      $NODE = Symbol("store-node"),
      $NAME = Symbol("store-name");
function wrap$1(value, name) {
  let p = value[solidJs.$PROXY];
  if (!p) {
    Object.defineProperty(value, solidJs.$PROXY, {
      value: p = new Proxy(value, proxyTraps$1)
    });
    const keys = Object.keys(value),
          desc = Object.getOwnPropertyDescriptors(value);
    for (let i = 0, l = keys.length; i < l; i++) {
      const prop = keys[i];
      if (desc[prop].get) {
        const get = desc[prop].get.bind(p);
        Object.defineProperty(value, prop, {
          get
        });
      }
    }
  }
  return p;
}
function isWrappable(obj) {
  return obj != null && typeof obj === "object" && (!obj.__proto__ || obj.__proto__ === Object.prototype || Array.isArray(obj));
}
function unwrap(item, set = new Set()) {
  let result, unwrapped, v, prop;
  if (result = item != null && item[$RAW]) return result;
  if (!isWrappable(item) || set.has(item)) return item;
  if (Array.isArray(item)) {
    if (Object.isFrozen(item)) item = item.slice(0);else set.add(item);
    for (let i = 0, l = item.length; i < l; i++) {
      v = item[i];
      if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;
    }
  } else {
    if (Object.isFrozen(item)) item = Object.assign({}, item);else set.add(item);
    const keys = Object.keys(item),
          desc = Object.getOwnPropertyDescriptors(item);
    for (let i = 0, l = keys.length; i < l; i++) {
      prop = keys[i];
      if (desc[prop].get) continue;
      v = item[prop];
      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;
    }
  }
  return item;
}
function getDataNodes(target) {
  let nodes = target[$NODE];
  if (!nodes) Object.defineProperty(target, $NODE, {
    value: nodes = {}
  });
  return nodes;
}
function proxyDescriptor(target, property) {
  const desc = Reflect.getOwnPropertyDescriptor(target, property);
  if (!desc || desc.get || property === solidJs.$PROXY || property === $NODE || property === $NAME) return desc;
  delete desc.value;
  delete desc.writable;
  desc.get = () => target[solidJs.$PROXY][property];
  return desc;
}
function createDataNode() {
  const [s, set] = solidJs.createSignal(undefined, {
    equals: false
  });
  s.$ = set;
  return s;
}
const proxyTraps$1 = {
  get(target, property, receiver) {
    if (property === $RAW) return target;
    if (property === solidJs.$PROXY) return receiver;
    const value = target[property];
    if (property === $NODE || property === "__proto__") return value;
    const wrappable = isWrappable(value);
    if (solidJs.getListener() && (typeof value !== "function" || target.hasOwnProperty(property))) {
      let nodes, node;
      if (wrappable && (nodes = getDataNodes(value))) {
        node = nodes._ || (nodes._ = createDataNode());
        node();
      }
      nodes = getDataNodes(target);
      node = nodes[property] || (nodes[property] = createDataNode());
      node();
    }
    return wrappable ? wrap$1(value) : value;
  },
  set() {
    return true;
  },
  deleteProperty() {
    return true;
  },
  getOwnPropertyDescriptor: proxyDescriptor
};
function setProperty(state, property, value) {
  if (state[property] === value) return;
  const array = Array.isArray(state);
  const len = state.length;
  const isUndefined = value === undefined;
  const notify = array || isUndefined === property in state;
  if (isUndefined) {
    delete state[property];
  } else state[property] = value;
  let nodes = getDataNodes(state),
      node;
  (node = nodes[property]) && node.$();
  if (array && state.length !== len) (node = nodes.length) && node.$(node, undefined);
  notify && (node = nodes._) && node.$(node, undefined);
}
function mergeStoreNode(state, value) {
  const keys = Object.keys(value);
  for (let i = 0; i < keys.length; i += 1) {
    const key = keys[i];
    setProperty(state, key, value[key]);
  }
}
function updatePath(current, path, traversed = []) {
  let part,
      prev = current;
  if (path.length > 1) {
    part = path.shift();
    const partType = typeof part,
          isArray = Array.isArray(current);
    if (Array.isArray(part)) {
      for (let i = 0; i < part.length; i++) {
        updatePath(current, [part[i]].concat(path), [part[i]].concat(traversed));
      }
      return;
    } else if (isArray && partType === "function") {
      for (let i = 0; i < current.length; i++) {
        if (part(current[i], i)) updatePath(current, [i].concat(path), [i].concat(traversed));
      }
      return;
    } else if (isArray && partType === "object") {
      const {
        from = 0,
        to = current.length - 1,
        by = 1
      } = part;
      for (let i = from; i <= to; i += by) {
        updatePath(current, [i].concat(path), [i].concat(traversed));
      }
      return;
    } else if (path.length > 1) {
      updatePath(current[part], path, [part].concat(traversed));
      return;
    }
    prev = current[part];
    traversed = [part].concat(traversed);
  }
  let value = path[0];
  if (typeof value === "function") {
    value = value(prev, traversed);
    if (value === prev) return;
  }
  if (part === undefined && value == undefined) return;
  value = unwrap(value);
  if (part === undefined || isWrappable(prev) && isWrappable(value) && !Array.isArray(value)) {
    mergeStoreNode(prev, value);
  } else setProperty(current, part, value);
}
function createStore(store, options) {
  const unwrappedStore = unwrap(store || {});
  const wrappedStore = wrap$1(unwrappedStore);
  function setStore(...args) {
    solidJs.batch(() => updatePath(unwrappedStore, args));
  }
  return [wrappedStore, setStore];
}

function applyState(target, parent, property, merge, key) {
  const previous = parent[property];
  if (target === previous) return;
  if (!isWrappable(target) || !isWrappable(previous) || key && target[key] !== previous[key]) {
    target !== previous && setProperty(parent, property, target);
    return;
  }
  if (Array.isArray(target)) {
    if (target.length && previous.length && (!merge || key && target[0][key] != null)) {
      let i, j, start, end, newEnd, item, newIndicesNext, keyVal;
      for (start = 0, end = Math.min(previous.length, target.length); start < end && (previous[start] === target[start] || key && previous[start][key] === target[start][key]); start++) {
        applyState(target[start], previous, start, merge, key);
      }
      const temp = new Array(target.length),
            newIndices = new Map();
      for (end = previous.length - 1, newEnd = target.length - 1; end >= start && newEnd >= start && (previous[end] === target[newEnd] || key && previous[end][key] === target[newEnd][key]); end--, newEnd--) {
        temp[newEnd] = previous[end];
      }
      if (start > newEnd || start > end) {
        for (j = start; j <= newEnd; j++) setProperty(previous, j, target[j]);
        for (; j < target.length; j++) {
          setProperty(previous, j, temp[j]);
          applyState(target[j], previous, j, merge, key);
        }
        if (previous.length > target.length) setProperty(previous, "length", target.length);
        return;
      }
      newIndicesNext = new Array(newEnd + 1);
      for (j = newEnd; j >= start; j--) {
        item = target[j];
        keyVal = key ? item[key] : item;
        i = newIndices.get(keyVal);
        newIndicesNext[j] = i === undefined ? -1 : i;
        newIndices.set(keyVal, j);
      }
      for (i = start; i <= end; i++) {
        item = previous[i];
        keyVal = key ? item[key] : item;
        j = newIndices.get(keyVal);
        if (j !== undefined && j !== -1) {
          temp[j] = previous[i];
          j = newIndicesNext[j];
          newIndices.set(keyVal, j);
        }
      }
      for (j = start; j < target.length; j++) {
        if (j in temp) {
          setProperty(previous, j, temp[j]);
          applyState(target[j], previous, j, merge, key);
        } else setProperty(previous, j, target[j]);
      }
    } else {
      for (let i = 0, len = target.length; i < len; i++) {
        applyState(target[i], previous, i, merge, key);
      }
    }
    if (previous.length > target.length) setProperty(previous, "length", target.length);
    return;
  }
  const targetKeys = Object.keys(target);
  for (let i = 0, len = targetKeys.length; i < len; i++) {
    applyState(target[targetKeys[i]], previous, targetKeys[i], merge, key);
  }
  const previousKeys = Object.keys(previous);
  for (let i = 0, len = previousKeys.length; i < len; i++) {
    if (target[previousKeys[i]] === undefined) setProperty(previous, previousKeys[i], undefined);
  }
}
function reconcile(value, options = {}) {
  const {
    merge,
    key = "id"
  } = options,
        v = unwrap(value);
  return s => {
    const state = s;
    if (!isWrappable(state) || !isWrappable(v)) return v;
    applyState(v, {
      state
    }, "state", merge, key);
    return state;
  };
}

const hasSchemeRegex = /^(?:[a-z0-9]+:)?\/\//i;
const normalizeRegex = /^\/+|\/+$|\s+/;

function normalize(path) {
  const s = path.replace(normalizeRegex, '');
  return s ? '/' + s : '';
}

function resolvePath(base, path, from) {
  if (hasSchemeRegex.test(path)) {
    return undefined;
  }

  const basePath = normalize(base);
  const fromPath = from && normalize(from);
  let result = '';

  if (!fromPath || path.charAt(0) === '/') {
    result = basePath;
  } else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {
    result = basePath + fromPath;
  } else {
    result = fromPath;
  }

  return result + normalize(path) || '/';
}
function createMatcher(path, options) {
  const {
    keys,
    pattern
  } = regexparam__default['default'](path, !options.end);
  return p => {
    const matches = pattern.exec(p);

    if (!matches) {
      return null;
    }

    const params = keys.reduce((acc, _, i) => {
      acc[keys[i]] = matches[i + 1];
      return acc;
    }, {});
    return [matches[0] || '/', params];
  };
}
function parseQuery(queryString) {
  return queryString.split('&').reduce((acc, pair) => {
    const [key, value] = pair.split('=', 2);

    if (key) {
      acc[key.toLowerCase()] = value;
    }

    return acc;
  }, {});
}
function renderPath(path) {
  return path;
}

const MAX_REDIRECTS = 100;
const RouterContext = solidJs.createContext();
const RouteContext = solidJs.createContext();
const useRouter = () => {
  const router = solidJs.useContext(RouterContext);

  if (!router) {
    throw new Error('No router context defined - ensure your application is wrapped with a Router component');
  }

  return router;
};
const useRoute = () => solidJs.useContext(RouteContext) || useRouter().base;
const defaultUtils = {
  resolvePath,
  createMatcher,
  parseQuery,
  renderPath
};

function normalizeIntegration(integration) {
  if (!integration) {
    return {
      signal: solidJs.createSignal({
        value: ''
      })
    };
  } else if (Array.isArray(integration)) {
    return {
      signal: integration
    };
  }

  return integration;
}

function createRouter(integration, basePath = '', overrides) {
  const {
    signal: [source, setSource],
    utils: intUtils
  } = normalizeIntegration(integration);
  const utils = { ...defaultUtils,
    ...intUtils,
    ...overrides
  };
  const path = utils.resolvePath('', basePath);

  if (path === undefined) {
    throw new Error(`${basePath} is not a valid base path`);
  } else if (path && !source().value) {
    setSource({
      value: path,
      mode: 'init'
    });
  }

  const baseRoute = createRouteState(utils, path, path, false, () => [path, {}]);
  const referrers = [];
  const [isRouting, start] = solidJs.useTransition();
  const [reference, setReference] = solidJs.createSignal(source().value);
  const [location] = createStore({
    get path() {
      return reference().split('?', 1)[0];
    },

    get queryString() {
      return reference().split('?', 2)[1] || '';
    }

  });

  function redirect(mode, to, options = {
    resolve: false
  }) {
    const currentRoute = solidJs.useContext(RouteContext) || baseRoute;
    const resolvedTo = options.resolve ? currentRoute.resolvePath(to) : utils.resolvePath('', to);

    if (resolvedTo === undefined) {
      throw new Error(`Path '${path}' is not a routable path`);
    }

    const redirectCount = referrers.push({
      ref: solidJs.untrack(reference),
      mode
    });

    if (redirectCount > MAX_REDIRECTS) {
      throw new Error('Too many redirects');
    }

    start(() => setReference(resolvedTo));
  }

  function handleRouteEnd(nextRef) {
    const first = referrers.shift();

    if (first) {
      if (nextRef !== first.ref) {
        setSource({
          value: nextRef,
          mode: first.mode
        });
      }

      referrers.length = 0;
    }
  }

  solidJs.createRenderEffect(() => {
    start(() => setReference(source().value));
  });
  solidJs.createRenderEffect(() => {
    handleRouteEnd(reference());
  });
  return {
    base: baseRoute,
    location,
    query: createMapMemo(() => location.queryString ? utils.parseQuery(location.queryString) : {}),
    isRouting,
    utils,

    push(to, options) {
      redirect('push', to, options);
    },

    replace(to, options) {
      redirect('replace', to, options);
    }

  };
}
function createRoute(pattern = '', end = false) {
  const router = useRouter();
  const parent = useRoute();
  const path = parent.resolvePath(pattern);

  if (path === undefined) {
    throw new Error(`${pattern} is not a valid path`);
  }

  if (parent.end && !end) {
    throw new Error(`Route '${path}' parent is a terminal route`);
  }

  const matcher = router.utils.createMatcher(path, {
    end
  });
  const match = solidJs.createMemo(() => matcher(router.location.path));
  return createRouteState(router.utils, router.base.path, path, end, match);
}
function createRouteState(utils, basePath, path, end, matchSignal) {
  const match = solidJs.createMemo(() => {
    const routeMatch = matchSignal();
    return routeMatch ? routeMatch[0] : undefined;
  });
  return {
    path,
    end,
    match,
    params: createMapMemo(() => {
      const routeMatch = matchSignal();
      return routeMatch ? routeMatch[1] : {};
    }),

    resolvePath(path) {
      const matchPath = match();
      return matchPath !== undefined ? utils.resolvePath(basePath, path, matchPath) : undefined;
    }

  };
}

function createMapMemo(fn) {
  const map = solidJs.createMemo(fn);
  const data = solidJs.createMemo(map, undefined, {
    equals: (a, b) => {
      reconcile(b, {
        key: null
      })(a);
      return true;
    }
  });
  const [state] = createStore({
    get map() {
      return data();
    }

  });
  return new Proxy({}, {
    get(_, key) {
      return state.map[key];
    },

    ownKeys() {
      return Reflect.ownKeys(map());
    },

    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }

  });
}

const _tmpl$ = web.template(`<a></a>`, 2);

function LinkBase(props) {
  const [, rest] = solidJs.splitProps(props, ['children', 'to', 'href', 'onClick']);
  const router = useRouter();
  const href = solidJs.createMemo(() => props.to !== undefined ? router.utils.renderPath(props.to) : props.href);

  const handleClick = evt => {
    const {
      onClick,
      to,
      target
    } = props;

    if (typeof onClick === 'function') {
      onClick(evt);
    } else if (onClick) {
      onClick[0](onClick[1], evt);
    }

    if (to !== undefined && !evt.defaultPrevented && evt.button === 0 && (!target || target === '_self') && !(evt.metaKey || evt.altKey || evt.ctrlKey || evt.shiftKey)) {
      evt.preventDefault();
      router.push(to, {
        resolve: false
      });
    }
  };

  return (() => {
    const _el$ = _tmpl$.cloneNode(true);

    _el$.$$click = handleClick;

    web.spread(_el$, rest, false, true);

    web.insert(_el$, () => props.children);

    web.effect(() => web.setAttribute(_el$, "href", href()));

    return _el$;
  })();
}

function Link(props) {
  const route = useRoute();
  const to = solidJs.createMemo(() => props.noResolve ? props.href : route.resolvePath(props.href));
  return web.createComponent(LinkBase, web.mergeProps(props, {
    get to() {
      return to();
    }

  }));
}
function NavLink(props) {
  props = solidJs.mergeProps({
    activeClass: 'is-active'
  }, props);
  const [, rest] = solidJs.splitProps(props, ['activeClass', 'end']);
  const router = useRouter();
  const route = useRoute();
  const to = solidJs.createMemo(() => props.noResolve ? props.href : route.resolvePath(props.href));
  const matcher = solidJs.createMemo(() => {
    const path = to();
    return path !== undefined ? router.utils.createMatcher(path, {
      end: !!props.end
    }) : undefined;
  });
  const isActive = solidJs.createMemo(() => {
    const m = matcher();
    return m && !!m(router.location.path);
  });
  return web.createComponent(LinkBase, web.mergeProps(rest, {
    get to() {
      return to();
    },

    get classList() {
      return {
        [props.activeClass]: isActive()
      };
    },

    get ["aria-current"]() {
      return isActive() ? 'page' : undefined;
    }

  }));
}
function Redirect(props) {
  const router = useRouter();
  const href = props.href;
  const path = typeof href === 'function' ? href(router) : href;
  router.replace(path, {
    resolve: !props.noResolve
  });
  return null;
}
function MatchRoute(props) {
  return web.createComponent(Route, web.mergeProps(props, {
    component: solidJs.Match
  }));
}

function renderChildren(props, args) {
  const children = props.children;
  return typeof children === 'function' && children.length ? solidJs.untrack(() => children(...args)) : children;
}

function Route(props) {
  const {
    path,
    end,
    component: Comp = solidJs.Show
  } = props;
  const router = useRouter();
  const route = createRoute(path, end);
  return web.createComponent(Comp, {
    get when() {
      return route.match() !== undefined;
    },

    get children() {
      return web.createComponent(RouteContext.Provider, {
        value: route,

        get children() {
          return renderChildren(props, [route, router]);
        }

      });
    }

  });
}
function Router(props) {
  const {
    integration,
    basePath,
    utils
  } = props;
  const router = createRouter(integration, basePath, utils);
  return web.createComponent(RouterContext.Provider, {
    value: router,

    get children() {
      return props.children;
    }

  });
}

web.delegateEvents(["click"]);

function bindEvent(target, type, handler) {
  target.addEventListener(type, handler);
  return () => target.removeEventListener(type, handler);
}

function intercept(signal, get, set) {
  const [value, setValue] = signal;
  return [get ? () => get(value()) : value, set ? v => setValue(set(v)) : setValue];
}

function createIntegration(get, set, init, utils) {
  const signal = intercept(solidJs.createSignal({
    value: get()
  }, {
    equals: (a, b) => a.value === b.value
  }), undefined, next => {
    const {
      value,
      mode
    } = next;
    mode && set(value, mode);
    return next;
  });
  init && solidJs.onCleanup(init((value = get()) => {
    signal[1]({
      value
    });
  }));
  return {
    signal,
    utils
  };
}
function pathIntegration() {
  return createIntegration(() => window.location.pathname + window.location.search, (value, mode) => {
    if (mode === 'push') {
      window.history.pushState(null, '', value);
    } else {
      window.history.replaceState(null, '', value);
    }
  }, notify => bindEvent(window, 'popstate', () => notify()));
}
function hashIntegration() {
  return createIntegration(() => window.location.hash.slice(1), value => {
    window.location.hash = value;
  }, notify => bindEvent(window, 'hashchange', () => notify()), {
    renderPath: path => `#${path}`
  });
}
function historyIntegration(history) {
  return createIntegration(() => history.location.pathname + history.location.search, (value, mode) => {
    if (mode === 'push') {
      history.push(value);
    } else {
      history.replace(value);
    }
  }, notify => history.listen(evt => {
    if (evt.action === 'POP') {
      notify();
    }
  }), {
    renderPath: history.createHref
  });
}

exports.Link = Link;
exports.MatchRoute = MatchRoute;
exports.NavLink = NavLink;
exports.Redirect = Redirect;
exports.Route = Route;
exports.Router = Router;
exports.createIntegration = createIntegration;
exports.createMatcher = createMatcher;
exports.createRoute = createRoute;
exports.createRouter = createRouter;
exports.hashIntegration = hashIntegration;
exports.historyIntegration = historyIntegration;
exports.parseQuery = parseQuery;
exports.pathIntegration = pathIntegration;
exports.renderPath = renderPath;
exports.resolvePath = resolvePath;
exports.useRoute = useRoute;
exports.useRouter = useRouter;
