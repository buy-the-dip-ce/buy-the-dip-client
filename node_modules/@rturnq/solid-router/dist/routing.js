import { createContext, useContext, createMemo, createSignal, createRenderEffect, useTransition, untrack } from 'solid-js';
import { createStore, reconcile } from 'solid-js/store';
import { createMatcher, parseQuery, resolvePath, renderPath } from './utils';
const MAX_REDIRECTS = 100;
export const RouterContext = createContext();
export const RouteContext = createContext();
export const useRouter = () => {
    const router = useContext(RouterContext);
    if (!router) {
        throw new Error('No router context defined - ensure your application is wrapped with a Router component');
    }
    return router;
};
export const useRoute = () => useContext(RouteContext) || useRouter().base;
export const defaultUtils = {
    resolvePath,
    createMatcher,
    parseQuery,
    renderPath
};
function normalizeIntegration(integration) {
    if (!integration) {
        return {
            signal: createSignal({ value: '' })
        };
    }
    else if (Array.isArray(integration)) {
        return {
            signal: integration
        };
    }
    return integration;
}
export function createRouter(integration, basePath = '', overrides) {
    const { signal: [source, setSource], utils: intUtils } = normalizeIntegration(integration);
    const utils = { ...defaultUtils, ...intUtils, ...overrides };
    const path = utils.resolvePath('', basePath);
    if (path === undefined) {
        throw new Error(`${basePath} is not a valid base path`);
    }
    else if (path && !source().value) {
        setSource({ value: path, mode: 'init' });
    }
    const baseRoute = createRouteState(utils, path, path, false, () => [
        path,
        {}
    ]);
    const referrers = [];
    const [isRouting, start] = useTransition();
    const [reference, setReference] = createSignal(source().value);
    const [location] = createStore({
        get path() {
            return reference().split('?', 1)[0];
        },
        get queryString() {
            return reference().split('?', 2)[1] || '';
        }
    });
    function redirect(mode, to, options = {
        resolve: false
    }) {
        const currentRoute = useContext(RouteContext) || baseRoute;
        const resolvedTo = options.resolve
            ? currentRoute.resolvePath(to)
            : utils.resolvePath('', to);
        if (resolvedTo === undefined) {
            throw new Error(`Path '${path}' is not a routable path`);
        }
        const redirectCount = referrers.push({
            ref: untrack(reference),
            mode
        });
        if (redirectCount > MAX_REDIRECTS) {
            throw new Error('Too many redirects');
        }
        start(() => setReference(resolvedTo));
    }
    function handleRouteEnd(nextRef) {
        const first = referrers.shift();
        if (first) {
            if (nextRef !== first.ref) {
                setSource({
                    value: nextRef,
                    mode: first.mode
                });
            }
            referrers.length = 0;
        }
    }
    createRenderEffect(() => {
        start(() => setReference(source().value));
    });
    createRenderEffect(() => {
        handleRouteEnd(reference());
    });
    return {
        base: baseRoute,
        location,
        query: createMapMemo(() => location.queryString ? utils.parseQuery(location.queryString) : {}),
        isRouting,
        utils,
        push(to, options) {
            redirect('push', to, options);
        },
        replace(to, options) {
            redirect('replace', to, options);
        }
    };
}
export function createRoute(pattern = '', end = false) {
    const router = useRouter();
    const parent = useRoute();
    const path = parent.resolvePath(pattern);
    if (path === undefined) {
        throw new Error(`${pattern} is not a valid path`);
    }
    if (parent.end && !end) {
        throw new Error(`Route '${path}' parent is a terminal route`);
    }
    const matcher = router.utils.createMatcher(path, { end });
    const match = createMemo(() => matcher(router.location.path));
    return createRouteState(router.utils, router.base.path, path, end, match);
}
export function createRouteState(utils, basePath, path, end, matchSignal) {
    const match = createMemo(() => {
        const routeMatch = matchSignal();
        return routeMatch ? routeMatch[0] : undefined;
    });
    return {
        path,
        end,
        match,
        params: createMapMemo(() => {
            const routeMatch = matchSignal();
            return routeMatch ? routeMatch[1] : {};
        }),
        resolvePath(path) {
            const matchPath = match();
            return matchPath !== undefined
                ? utils.resolvePath(basePath, path, matchPath)
                : undefined;
        }
    };
}
function createMapMemo(fn) {
    const map = createMemo(fn);
    const data = createMemo(map, undefined, {
        equals: (a, b) => {
            reconcile(b, { key: null })(a);
            return true;
        }
    });
    const [state] = createStore({
        get map() {
            return data();
        }
    });
    return new Proxy({}, {
        get(_, key) {
            return state.map[key];
        },
        ownKeys() {
            return Reflect.ownKeys(map());
        },
        getOwnPropertyDescriptor() {
            return {
                enumerable: true,
                configurable: true
            };
        }
    });
}
