import { Show, Match, createMemo, splitProps, untrack, mergeProps } from 'solid-js';
import { useRouter, createRouter, createRoute, RouterContext, RouteContext, useRoute } from './routing';
function LinkBase(props) {
    const [, rest] = splitProps(props, ['children', 'to', 'href', 'onClick']);
    const router = useRouter();
    const href = createMemo(() => props.to !== undefined ? router.utils.renderPath(props.to) : props.href);
    const handleClick = (evt) => {
        const { onClick, to, target } = props;
        if (typeof onClick === 'function') {
            onClick(evt);
        }
        else if (onClick) {
            onClick[0](onClick[1], evt);
        }
        if (to !== undefined &&
            !evt.defaultPrevented &&
            evt.button === 0 &&
            (!target || target === '_self') &&
            !(evt.metaKey || evt.altKey || evt.ctrlKey || evt.shiftKey)) {
            evt.preventDefault();
            router.push(to, { resolve: false });
        }
    };
    return (<a {...rest} href={href()} onClick={handleClick}>
      {props.children}
    </a>);
}
export function Link(props) {
    const route = useRoute();
    const to = createMemo(() => props.noResolve ? props.href : route.resolvePath(props.href));
    return <LinkBase {...props} to={to()}/>;
}
export function NavLink(props) {
    props = mergeProps({ activeClass: 'is-active' }, props);
    const [, rest] = splitProps(props, ['activeClass', 'end']);
    const router = useRouter();
    const route = useRoute();
    const to = createMemo(() => props.noResolve ? props.href : route.resolvePath(props.href));
    const matcher = createMemo(() => {
        const path = to();
        return path !== undefined
            ? router.utils.createMatcher(path, { end: !!props.end })
            : undefined;
    });
    const isActive = createMemo(() => {
        const m = matcher();
        return m && !!m(router.location.path);
    });
    return (<LinkBase {...rest} to={to()} classList={{ [props.activeClass]: isActive() }} aria-current={isActive() ? 'page' : undefined}/>);
}
export function Redirect(props) {
    const router = useRouter();
    const href = props.href;
    const path = typeof href === 'function' ? href(router) : href;
    router.replace(path, { resolve: !props.noResolve });
    return null;
}
export function MatchRoute(props) {
    return <Route {...props} component={Match}/>;
}
function renderChildren(props, args) {
    const children = props.children;
    return typeof children === 'function' && children.length
        ? untrack(() => children(...args))
        : children;
}
export function Route(props) {
    const { path, end, component: Comp = Show } = props;
    const router = useRouter();
    const route = createRoute(path, end);
    return (<Comp when={route.match() !== undefined}>
      <RouteContext.Provider value={route}>
        {renderChildren(props, [route, router])}
      </RouteContext.Provider>
    </Comp>);
}
export function Router(props) {
    const { integration, basePath, utils } = props;
    const router = createRouter(integration, basePath, utils);
    return (<RouterContext.Provider value={router}>
      {props.children}
    </RouterContext.Provider>);
}
